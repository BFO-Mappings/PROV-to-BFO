PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX swrl: <http://www.w3.org/2003/11/swrl#> 

PREFIX prov: <http://www.w3.org/ns/prov#>
PREFIX bfo: <http://purl.obolibrary.org/obo/BFO_>
PREFIX ro: <http://purl.obolibrary.org/obo/RO_>
PREFIX cco: <http://www.ontologyrepository.com/CommonCoreOntologies/>

# Note: filters only work when all referenced terms and their axioms are succesfully imported

SELECT DISTINCT ?targetTerm ?label
# ?termType 
WHERE {
  # What kinds of things are we mapping?
  VALUES ?termType { owl:Class owl:ObjectProperty } .

  # What target ontology are we mapping to?
  FILTER ( STRSTARTS(STR(?targetTerm), STR(prov:)) ) .
  
  FILTER NOT EXISTS {
    # Optionally filter on predicate type
    # VALUES ?mappingPredicate { rdfs:subClassOf rdfs:subPropertyOf owl:equivalentClass owl:equivalentProperty owl:disjointUnionOf } .
    
    FILTER ( STRSTARTS(STR(?sourceTerm), STR(bfo:)) || STRSTARTS(STR(?sourceTerm), STR(ro:)) || STRSTARTS(STR(?sourceTerm), STR(cco:)) ) .

    # Exclude mapped terms
    { 
      ?targetTerm ?mappingPredicate ?sourceTerm .
    }
    # Exclude terms that are transitively subsumed by some mapped term
    UNION
    { 
      ?targetTerm rdfs:subClassOf* ?targetSuper . 
      ?targetSuper ?mappingPredicate ?sourceTerm .
    }
    UNION
    {
      ?targetTerm rdfs:subPropertyOf* ?targetSuper . 
      ?targetSuper ?mappingPredicate ?sourceTerm .
    }
    # Exclude terms whose inverses are mapped
    UNION
    {
      ?targetTerm owl:inverseOf ?targetInverse .
      ?targetInverse ?mappingPredicate ?sourceTerm .
    }
  }

  # Exclude property chain mappings
  FILTER NOT EXISTS {
    FILTER ( STRSTARTS(STR(?sourceTerm), STR(bfo:)) || STRSTARTS(STR(?sourceTerm), STR(ro:)) || STRSTARTS(STR(?sourceTerm), STR(cco:)) ) .
    {
      # Exclude terms that have a property chain mapping
      ?targetTerm owl:propertyChainAxiom ?propertyChainAxiomList .
      ?propertyChainAxiomList rdf:rest/rdf:first ?sourceTerm .
    }
    UNION
    {
      # Exclude terms whose inverse have a property chain mapping
      ?targetInverse owl:inverseOf ?targetTerm .
      ?targetInverse owl:propertyChainAxiom ?inversePropertyChainAxiomList .
      {
        ?inversePropertyChainAxiomList rdf:rest/rdf:first ?sourceTerm .
      }
    }
  }

  # Exclude SWRL rule mappings
  FILTER NOT EXISTS {
    FILTER ( STRSTARTS(STR(?sourceTerm), STR(bfo:)) || STRSTARTS(STR(?sourceTerm), STR(ro:)) || STRSTARTS(STR(?sourceTerm), STR(cco:)) ) .
    # TODO this is needed for some reason
    ?sourceTerm a ?anything .

    # TODO: Require that either source term in head and target term in body, or vica versa
    { ?swrlMapping swrl:propertyPredicate ?targetTerm . }
    UNION
    { ?swrlMapping swrl:propertyPredicate ?mappedTerm . ?mappedTerm owl:inverseOf ?targetTerm . }
  }

  ?targetTerm a ?termType .
  ?targetTerm rdfs:label ?label .
  # OPTIONAL { ?targetTerm rdfs:subClassOf ?targetSuperClass } .
  # OPTIONAL { ?targetTerm rdfs:subPropertyOf ?targetSuperProperty } .
} ORDER BY ?termType ?targetTerm